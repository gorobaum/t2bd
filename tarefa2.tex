\documentclass[conference]{IEEEtran}

\usepackage{array}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{hyperref}
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}

\title{Panorama prático sobre estado atual dos bancos de dados ativos}

\author{\IEEEauthorblockN{Caio de freitas Valente\IEEEauthorrefmark{1}, Gabriel Reganati\IEEEauthorrefmark{2},  Rafael Reggiani Manzo\IEEEauthorrefmark{3}, Thiago de Gouveia Nunes\IEEEauthorrefmark{4}}
\IEEEauthorblockA{Instituto de Matemática e Estatística\\
Universidade de São Paulo\\
São Paulo, São Paulo\\
Emails: \IEEEauthorrefmark{3}manzo@ime.usp.br, \IEEEauthorrefmark{4}thiago.gouveia.nunes@gmail.com}
}

\maketitle
\IEEEpeerreviewmaketitle

\section{Introdução}
  \subsection{Motivação e contextualização (Gordo)}
	Passar nessa porra.

  Coisas da aula...

  \subsection{Conceitos}
  Citando artigo resumido pelo Caio... (Caio)

\section{Estado da arte}
  \subsection{Trabalhos científicos}
    \subsubsection{Practical Applications of Triggers and Constraints: Successes and Lingering Issues}
    O artigo “Practical Applications of Triggers and Constraints: Successes and Lingering Issues” faz uma breve revisão sobre restrições e triggers, descreve dois métodos diferentes para agrupamento e comenta um pouco sobre os problemas e vantagens relacionados ao uso seu uso.

    Triggers são baseadas no modelo ECA (Event Condition Action), quando um evento ocorre e alguma condição associada é verdadeira, executamos uma ação. Em relação ao seu comportamento, podemos definir muitas coisas como, sua granularidade, o trigger age em nível de linha ou tabela, a ordem da ação, ou seja se a ação deve ser executada antes, depois ou ao invés do evento que o disparou. As condições e funções são definidas arbitrariamente. Note que podemos utilizar os valores que existiam antes do evento ser disparado e depois.

    Triggers surgiram como uma forma de reação automática a violações de restrições de integridade, e logo foram generalizados para realização de outras tarefas, se tornando o modelo ECA que temos hoje. Os primeiros produtos que suportavam triggers surgiram no começo da década de 90, hoje em dia todos os vendedores de SGBDs relacionais tem suporte a triggers.

    Triggers podem ser classificados da seguinte maneira:

    \begin{table}[H]
        \begin{tabular}{p{8cm}p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            \vspace{0pt}
             DBMS Kernel
            \vspace{0pt}
            DBMS Services
            \vspace{0pt}
            External Applications
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Handcrafted
            \vspace{0pt}
            Gerenciamento de metadados, auditoria interna
            \vspace{0pt}
            NA
            \vspace{0pt}
            Regras de negócio, Escalonamento, Gerenciamento de “cadeia de suprimentos”
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Generated
            \vspace{0pt}
            Integridade referencial, materialized views
            \vspace{0pt}
            Replicação, Extenders, Auditoria, Migração, Alertas
            \vspace{0pt}
            Gerenciamento de Workflow
        \end{tabular}
    \end{table}

    \begin{itemize}
        \item{Handcrafted}: São triggers criados por algum programador.
        \item{Generated}: Triggers gerados automaticamente
        \item{Kernel}: Triggers escritos no Kernel, para não esbarrar em problemas de segurança ou então melhorar a performance
        \item{Services}: Serviços que tem como proposito prover ou melhorar alguma funcionalidade do SGBD
        \item{External}: Estão fora do banco de dados, fazem acesso ou se comunicam por meio de alguma API
    \end{itemize}

    Podemos ainda classificar os triggers em relação a sua função:
    \begin{table}[H]
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
           Triggers que preservam restrições
            \vspace{0pt}
           Rollback caso as restrições sejam invalidadas
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Triggers que preservam restrições
            \vspace{0pt}
           Altera o valor para se conformar as restrições
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Triggers que sinalizam violações de restrições
            \vspace{0pt}
           Sinaliza para a aplicação, que deverá cuidar do problema
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Materializing Trigger
            \vspace{0pt}
           Mantêm a consistência da materialized view
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
           Metadata Trigger
            \vspace{0pt}
           Mantêm a consistencia dos metadados
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
           Replication Trigger
            \vspace{0pt}
           Mantêm a consistencia de dados replicados de uma tabela para outra
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
           Extenders
            \vspace{0pt}
           Gerencia novos tipos de dados e os mantêm consistentes com o banco de dados.
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
           Alerter
            \vspace{0pt}
           Notifica o usuário via manesagens
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Ad-Hoc Trigger
            \vspace{0pt}
            São triggers especificos para cada aplicação -> Regras de negócio, workflow, web, etc.
        \end{tabular}
    \end{table}

    A grande vantagem do uso de triggers é a possibilidade de mover a lógica e regras de negócio da aplicação para o banco de dados.

    Algumas das reclamações estão relacionadas a expressividade dos triggers. Há certos problemas de padronização, comportamentos particulares de cada SGBD podem ter grande impacto nos resultados finais. Além disso não há falta de ferramentas que ajudem na análise de triggers, esse é um dos motivos que levou o crescimento de triggers gerados automaticamente. Muitos triggers, ou triggers complexos deterioram muito a performance.

    \subsubsection{\textit{Toward an Active Database Platform for Guiding Urban Pedestrians}}
    Utilizando a extensão \textit{PotsGIS} do sistema gerenciador de banco de dados (SGBD) PostgreSQL, que adiciona a capacidade de um tipo de dado para posição geográfica, este estudo da Universidade de Ume\r{a} na Suécia de autoria de Michael Minock, Johan Mollevik and Mattias \r{A}sander, através do uso extensivo de \textit{stored procedures} foi capaz de fornercer instruções de direção a fim de guiar um pedestre em um trajeto.

    Este banco de dados foi modelado para centralizar todo o estado do sistema como descrição dos mapas, posições do usuário, rotas e registro dos avisos enviados ao usuário. São basicamente quatro relações: \textit{PathNetwork}; \textit{Landmarks}; \textit{Routes}; e \textit{Pedestrian}.

    O primeiro uso de banco de dados ativo citado, é quando uma nova medição de \textit{GPS} é adicionada à base de dados, é disparado um \textit{trigger} que por sua vez executa uma \textit{stored procedure} que atualiza o estado do pedestre. Este tipo de ação é executado com alta frequência (uma vez por segundo).

    Estas modificações no estado do pedestre então podem desencadear outras regras para decidir quando enviar avisos sonoros ao pedestre, corrigir a rota quando o usuário sai do planejado, informar a distância restante e até mesmo encorajá-lo em sua caminhada. Tudo programado com \textit{triggers} e \textit{stored procedures}.

    Por outro lado, muitos destes eventos podem acontecer simultâneamente e para evitar que diversos avisos sejam disparados ao mesmo tempo, foi criada uma regra na inclusão da relação de avisos.

    Esta implementação obteve boa performance com atraso de resposta médio de 60ms. Quanto à precisão da navegação, os autores foram sinceros em dizer que ainda não está tão preciso quanto soluções a soluções de navegação comerciais. Mas também apontou quais pontos precisam ser melhorados para chegar a este ponto.

  \subsection{Ferramentas}
  Tabela comparativa (arrumar célula F20, tirar function e procedure, filtrar só os principais bancos) (Gordo)
  \begin{table*}[!t]
    \renewcommand{\arraystretch}{1}
    \caption{Tabela de Ferramentas}
    \label{table_example}
    \centering
    \begin{tabular}{ c  c  c  c  c  c }
      \hline
      \bfseries Nome & \bfseries Trigger & \bfseries Primeiro release & \bfseries Última versão estável & \bfseries Último release & \bfseries Licensa \\
      \hline
      Apache Derby & Sim & 2004 & 10.10.1.1 & 2013 & Apache License \\
      \hline
      DB2 & Sim & 1983 & 10.5 & 2013 & Proprietária \\
      \hline
      H2 & Sim & 2005 & 1.3.171 & 2013 & EPL e modificação da MPL \\
      \hline
      HSQLDB & Sim & 2001 & 2.2.9 & 2013 & BSD \\
      \hline
      Microsoft Access (NET) & Não & 1992 & 15 & 2012 & Proprietária \\
      \hline
      Microsoft Azure SQL & Sim & 2010 & & 2012 & Proprietária \\
      \hline
      Microsoft SQL Server & Sim & 1989 & 2012 &  &  Proprietária \\
      \hline
      Microsoft SQL Server Compact (Embedded Database) & Não & 2000 & 2011 & & Proprietária \\
      \hline
      MonetDB & Sim & 2004 & 11.9.1 & 2012 & MonetDB Public License v1.1 \\
      \hline
      MongoDB & Não & 2009 & 2.4.6 & 2013 & GNU AGPL v3.0 \\
      \hline
      MySQL & Sim & 1995 & 5.6.31 & 2013 & GPL ou Proprietária\\
      \hline
      Oracle & Sim & 1979 & 12c Release 1 & 2013 & Proprietária\\
      \hline
      Oracle Rdb  & Sim & 1984 & 7.2.5.3.0 & 2013 & Proprietária\\
      \hline
      PostgreSQL & Sim & 1989 & 9.3.1 & 2013 & PostgreSQL Licence (a liberal Open Source license) \\
      \hline
      RDM Embedded & Não & 1984 & 11.0 & 2012 & Proprietária \\
      \hline
      RDM Server & Sim & 1993 & 8.4 & 2012 & Proprietária \\
      \hline
      SQLite & Sim & 1905 & 3.8.0.2 & 2013 & Dominio Público \\
      \hline
      Xeround Cloud Database & Sim & 2010 & 3.1 & 2011 & SaaS \\
      \hline
    \end{tabular}
  \end{table*}

\section{Estudo de caso}
  \subsection{Características técnicas}
    \subsubsection{SQLServer (Gabriel)}
O MS SQL Server é um SGBD - sistema gerenciador de Banco de dados relacional desenvolvido pela Microsoft. Foi criado em parceria com a Sybase em 1988 inicialmente para a plataforma OS/21 . Esta parceria durou até 1994, com o lançamento da versão para Windows NT e desde então a Microsoft mantém a manutenção do produto. O SQL não é Open Source e para utilizar o SQL Server é necessário comprar uma versão da Microsoft. Suas linguagens de consulta primárias são T-SQL e ANSI SQL.\\
	O SQL Server tem como principais características:
\begin{itemize}
\item Funciona no sistema operacional Windows
\item Tem como tamanho máximo de banco de dados como 524 TB  e tamanho máximo de tabela como 524 TB
\item Suporte a multi-threads
\item A interface Connector/ODBC fornece ao SQL Server suporte a programas clientes que usam conexão ODBC (Open-DataBase-Connectivity).
\item Suporte nativo ao XML
\item Suporte a internacionalização
\item Suporte a Data Warehouse
\end{itemize}

    \subsubsection{MySQL (Gabriel)}
	MySQL é o mais popular sistema de gerenciamento de banco de dados SQL Open Source, é desenvolvido, distribuído e tem suporte da MySQL AB. A MySQL AB é uma empresa comercial, fundada pelos desenvolvedores do MySQL, cujos negócios é fornecer serviços relacionados ao sistema de gerenciamento de banco de dados MySQL\\
	O MySQL tem como principais características:
\begin{itemize}
\item Escrito em C e C++.
\item Funciona em diversas plataformas, como Windows, Linux 2.0+, OpenBSD, FreeBSD, SunOS 4.x e outros
\item Utiliza o GNU Automake, Autoconf, e Libtool para portabilidade.
\item Suporte total a multi-threads usando threads diretamente no kernel. Isto significa que se pode facilmente usar múltiplas CPUs, se disponível.
\item Completo suporte a operadores e funções da linguagem SQL para consultas e funções
\item Um sistema de privilégios e senhas que é muito flexível, seguro e que permite verificação baseada em estações/máquinas. Senhas são seguras porque todo o tráfico de senhas é criptografado quando você se conecta ao servidor.
\item Os clientes podem se conectar ao servidor MySQL usando sockets TCP/IP, em qualquer plataforma.
\item A interface Connector/ODBC fornece ao MySQL suporte a programas clientes que usam conexão ODBC (Open-DataBase-Connectivity). 
\item O servidor pode apresentar mensagem de erros aos clientes em várias línguas. 
\item Suporte total para vários conjuntos de caracteres, que incluem ISO-8859-1 (Latin1), big5, ujis e mais.
\item Tem como tamanho máximo de banco de dados como ilimitado e tamanho máximo de tabela como 256 TB
\end{itemize}


  \subsection{Cenário}
    \subsubsection{O Problema} Ao se deparar com a criação de um sistema web o qual realizaria a venda de papel moeda e cartões pré-pagos internacionais pela internet, teve-se que pensar em como fazer a atualização das taxas de moedas a serem vendidas a partir de um serviço externo com atualizações periódicas, que consistem de chamadas bastante demoradas tanto pelo volume de dados quanto pelo tempo de resposta do serviço externo.\\
    Além disso a compra de cambio apresenta uma validade de 2 dias, portanto o banco de dados deveria ser possível cancelar a compra caso não fosse efetuada no período de dois dias.

    \subsubsection{A Solução} Para que a cada requisição de um usuário pela taxa de câmbio de uma moeda não resulte em uma requisição deste tipo para um serviço externo, foi pensada uma tabela de \textit{cache} para as cotações que por é atualizada por meio de regras ativas. Assim, ao invés de acessar um serviço externo, a operação de obter a taxa de câmbio consiste de uma simples consulta a tabela.\\
    Com o intuito de solucionar o problema da validade foram feitas triggers que façam esse tipo de análise e assim trocando validando ou não a compra.

  \subsection{Descição dos testes}
  A fim de aferir as capacidades dos SGBDs SQLServer e MySQL quanto a utilização de regras ativas, e tendo em mente o cenário anteriormente descrito, foram elaborados dois casos de teste a serem realizados em ambas os sistemas:

  \begin{enumerate}
    \item Execução periódica de uma regra para atualizar as informações sobre taxa de câmbio;
    \item Invalidãção de compras realizadas há mais de dois dias.
  \end{enumerate}

  \subsection{Modelagens}
    \subsubsection{MySQL}
    Para os testes com o SGBD MySQL, foi adotada a seguinte modelagem com quatro relações: Boleto; Cambio; Taxa; e Moeda.

    A relação Boleto representa uma operação de compra realizada, contendo os atributos id, data, pago (booleano), valor e id\_cambio.

    Por sua vez a relação Cambio representa as taxas do dia de uma dada moeda para outra com atributos id, id\_taxa\_origem, id\_taxa\_destino.

    Assim como deve ter sido possível inferir pelo nome, a relação Taxa, com atributos id, data, id\_moeda e valor, representa uma taxa de conversão para uma dada moeda em uma dada data.

    Por fim, a relação Moeda contém apenas o nome desta e sua id.



    \subsubsection{SQLServer (Caio e Gabriel)}
	Usamos a ferramenta SQL Server Management Studio para trabalhar com SQL Server.			
	Decidimos seguir o mesmo padrão usado na resolução do problema com MySQL, segue o diagrama das tabelas:
 
	\includegraphics[scale=0.7]{img/tabela.jpg} 

	Em seguida desenvolvemos uma aplicação web que a partir do nome de uma moeda busca no Google a taxa de cambio em relação ao Real. Esse valor já parseado é retornado. Segue o link:\\ \\
	\href{http://trabalho2db.azurewebsites.net/Currency/Get?exchangeRate=}{http://trabalho2db.azurewebsites.net/Currency/Get?exchangeRate=} \\ \\
	Exemplo de uso:\href{http://trabalho2db.azurewebsites.net/Currency/Get?exchangeRate=USD}{http://trabalho2db.azurewebsites.net/Currency/Get?exchangeRate=USD} \\ \\

	Criamos o stored procedure AtualizaTaxa, que para toda entrada na tabela Moeda envia o valor seu nome para a aplicação web, e cria uma nova entrada em taxa com seu horário da atualização e valor obtido.

	O próximo passo foi criar o stored procedure AtualizaTaxaDeCambio para associar todas as taxas obtidas em origens e destinos, por exemplo supondo que temos no banco de dados a taxa das seguintes moedas: USD, EUR e BRL vamos obter em Cambio as seguintes combinações: USD-USD, USD-EUR, USD-BRL, EUR-USD, EUR-EUR, EUR-BRL, BRL-USD, BRL-EUR, BRL-BRL.

	Os dois stored procedures acima são executados de cinco em cinco minutos. SQL Server não suporta triggers usando tempo diretamente, mas podemos fazer uma construção equivalente usando Jobs para executar os stored procedures na frequência desejada.

	Finalmente, usando um trigger, quando o usuário realiza uma compra, é especificado o valor em moedas destino que deseja comprar, usando essa informação e as informações de cambio mais recentes podemos calcular o valor da compra. O status da compra fica pendente até o usuário pagar o valor da compra, e nesse caso o status passa para finalizado, ou então até dois dias após o início da transação e nesse caso usamos um job para alterar o status do boleto para cancelado.


  \subsection{Resultados}
    \subsubsection{MySQL (Manzo \& Gordo)}
    \subsubsection{SQLServer (Caio e Gabriel)}

\begin{thebibliography}{1}

\bibitem{sweedish-article}
M. Minock, J. Mollevik and M. \r{A}sander, \textit{Toward an Active Database Platform for Guiding Urban Pedestrians}. Ume\r{a}, Sweden: University of Ume\r{a}, 2012.
\bibitem{mysql-site}
http://ftp.nchu.edu.tw/MySQL/doc/refman/4.1/pt/
\bibitem{sql-server-site}
http://msdn.microsoft.com/en-us/library/cc645993.aspx
\end{thebibliography}

\end{document}

