\documentclass[conference]{IEEEtran}

\usepackage{array}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}

\title{Panorama prático sobre estado atual dos bancos de dados ativos}

\author{\IEEEauthorblockN{Caio de freitas Valente\IEEEauthorrefmark{1}, Gabriel Reganati\IEEEauthorrefmark{2},  Rafael Reggiani Manzo\IEEEauthorrefmark{3}, Thiago de Gouveia Nunes\IEEEauthorrefmark{4}}
\IEEEauthorblockA{Instituto de Matemática e Estatística\\
Universidade de São Paulo\\
São Paulo, São Paulo\\
Emails: \IEEEauthorrefmark{3}manzo@ime.usp.br, \IEEEauthorrefmark{4}thiago.gouveia.nunes@gmail.com}
}

\maketitle
\IEEEpeerreviewmaketitle

\section{Introdução}
  \subsection{Motivação e contextualização (Gordo)}
	Passar nessa porra.

  Coisas da aula...

  \subsection{Conceitos}
  Citando artigo resumido pelo Caio... (Caio)

\section{Estado da arte}
  \subsection{Trabalhos científicos}
    \subsubsection{Practical Applications of Triggers and Constraints: Successes and Lingering Issues}
    O artigo “Practical Applications of Triggers and Constraints: Successes and Lingering Issues” faz uma breve revisão sobre restrições e triggers, descreve dois métodos diferentes para agrupamento e comenta um pouco sobre os problemas e vantagens relacionados ao uso seu uso.

    Triggers são baseadas no modelo ECA (Event Condition Action), quando um evento ocorre e alguma condição associada é verdadeira, executamos uma ação. Em relação ao seu comportamento, podemos definir muitas coisas como, sua granularidade, o trigger age em nível de linha ou tabela, a ordem da ação, ou seja se a ação deve ser executada antes, depois ou ao invés do evento que o disparou. As condições e funções são definidas arbitrariamente. Note que podemos utilizar os valores que existiam antes do evento ser disparado e depois.

    Triggers surgiram como uma forma de reação automática a violações de restrições de integridade, e logo foram generalizados para realização de outras tarefas, se tornando o modelo ECA que temos hoje. Os primeiros produtos que suportavam triggers surgiram no começo da década de 90, hoje em dia todos os vendedores de SGBDs relacionais tem suporte a triggers.

    Triggers podem ser classificados da seguinte maneira:

    \begin{table}[H]
        \begin{tabular}{p{8cm}p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            \vspace{0pt}
             DBMS Kernel
            \vspace{0pt}
            DBMS Services
            \vspace{0pt}
            External Applications
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Handcrafted
            \vspace{0pt}
            Gerenciamento de metadados, auditoria interna
            \vspace{0pt}
            NA
            \vspace{0pt}
            Regras de negócio, Escalonamento, Gerenciamento de “cadeia de suprimentos”
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Generated
            \vspace{0pt}
            Integridade referencial, materialized views
            \vspace{0pt}
            Replicação, Extenders, Auditoria, Migração, Alertas
            \vspace{0pt}
            Gerenciamento de Workflow
        \end{tabular}
    \end{table}

    \begin{itemize}
        \item{Handcrafted}: São triggers criados por algum programador.
        \item{Generated}: Triggers gerados automaticamente
        \item{Kernel}: Triggers escritos no Kernel, para não esbarrar em problemas de segurança ou então melhorar a performance
        \item{Services}: Serviços que tem como proposito prover ou melhorar alguma funcionalidade do SGBD
        \item{External}: Estão fora do banco de dados, fazem acesso ou se comunicam por meio de alguma API
    \end{itemize}

    Podemos ainda classificar os triggers em relação a sua função:
    \begin{table}[H]
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
           Triggers que preservam restrições
            \vspace{0pt}
           Rollback caso as restrições sejam invalidadas
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Triggers que preservam restrições
            \vspace{0pt}
           Altera o valor para se conformar as restrições
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Triggers que sinalizam violações de restrições
            \vspace{0pt}
           Sinaliza para a aplicação, que deverá cuidar do problema
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Materializing Trigger
            \vspace{0pt}
           Mantêm a consistência da materialized view
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
           Metadata Trigger
            \vspace{0pt}
           Mantêm a consistencia dos metadados
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
           Replication Trigger
            \vspace{0pt}
           Mantêm a consistencia de dados replicados de uma tabela para outra
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
           Extenders
            \vspace{0pt}
           Gerencia novos tipos de dados e os mantêm consistentes com o banco de dados.
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
           Alerter
            \vspace{0pt}
           Notifica o usuário via manesagens
        \end{tabular}
        \begin{tabular}{p{8cm}p{8cm}p{8cm}}
            \vspace{0pt}
            Ad-Hoc Trigger
            \vspace{0pt}
            São triggers especificos para cada aplicação -> Regras de negócio, workflow, web, etc.
        \end{tabular}
    \end{table}

    A grande vantagem do uso de triggers é a possibilidade de mover a lógica e regras de negócio da aplicação para o banco de dados.

    Algumas das reclamações estão relacionadas a expressividade dos triggers. Há certos problemas de padronização, comportamentos particulares de cada SGBD podem ter grande impacto nos resultados finais. Além disso não há falta de ferramentas que ajudem na análise de triggers, esse é um dos motivos que levou o crescimento de triggers gerados automaticamente. Muitos triggers, ou triggers complexos deterioram muito a performance.

    \subsubsection{\textit{Toward an Active Database Platform for Guiding Urban Pedestrians}}
    Utilizando a extensão \textit{PotsGIS} do sistema gerenciador de banco de dados (SGBD) PostgreSQL, que adiciona a capacidade de um tipo de dado para posição geográfica, este estudo da Universidade de Ume\r{a} na Suécia de autoria de Michael Minock, Johan Mollevik and Mattias \r{A}sander, através do uso extensivo de \textit{stored procedures} foi capaz de fornercer instruções de direção a fim de guiar um pedestre em um trajeto.

    Este banco de dados foi modelado para centralizar todo o estado do sistema como descrição dos mapas, posições do usuário, rotas e registro dos avisos enviados ao usuário. São basicamente quatro relações: \textit{PathNetwork}; \textit{Landmarks}; \textit{Routes}; e \textit{Pedestrian}.

    O primeiro uso de banco de dados ativo citado, é quando uma nova medição de \textit{GPS} é adicionada à base de dados, é disparado um \textit{trigger} que por sua vez executa uma \textit{stored procedure} que atualiza o estado do pedestre. Este tipo de ação é executado com alta frequência (uma vez por segundo).

    Estas modificações no estado do pedestre então podem desencadear outras regras para decidir quando enviar avisos sonoros ao pedestre, corrigir a rota quando o usuário sai do planejado, informar a distância restante e até mesmo encorajá-lo em sua caminhada. Tudo programado com \textit{triggers} e \textit{stored procedures}.

    Por outro lado, muitos destes eventos podem acontecer simultâneamente e para evitar que diversos avisos sejam disparados ao mesmo tempo, foi criada uma regra na inclusão da relação de avisos.

    Esta implementação obteve boa performance com atraso de resposta médio de 60ms. Quanto à precisão da navegação, os autores foram sinceros em dizer que ainda não está tão preciso quanto soluções a soluções de navegação comerciais. Mas também apontou quais pontos precisam ser melhorados para chegar a este ponto.

  \subsection{Ferramentas}
  Tabela comparativa (arrumar célula F20, tirar function e procedure, filtrar só os principais bancos) (Gordo)

\section{Estudo de caso}
  \subsection{Características técnicas}
    \subsubsection{SQLServer (Gabriel)}
    \subsubsection{MySQL (Gabriel)}

  \subsection{Cenário}
    \subsubsection{O Problema}
    Ao se deparar com a criação de um sistema web o qual realizaria a venda de papel moeda e cartões pré-pagos internacionais pela internet, teve-se que pensar em como fazer a atualização das taxas de moedas a serem vendidas a partir de um serviço externo com atualizações periódicas, que consistem de chamadas bastante demoradas tanto pelo volume de dados quanto pelo tempo de resposta do serviço externo.

    \subsubsection{A Solução}
    Para que a cada requisição de um usuário pela taxa de câmbio de uma moeda não resulte em uma requisição deste tipo para um serviço externo, foi pensada uma tabela de \textit{cache} para as cotações que por é atualizada por meio de regras ativas. Assim, ao invés de acessar um serviço externo, a operação de obter a taxa de câmbio consiste de uma simples consulta a tabela.

  \subsection{Descição dos testes}
  A fim de aferir as capacidades dos SGBDs SQLServer e MySQL quanto a utilização de regras ativas, e tendo em mente o cenário anteriormente descrito, foram elaborados dois casos de teste a serem realizados em ambas os sistemas:

  \begin{enumerate}
    \item Execução periódica de uma regra para atualizar as informações sobre taxa de câmbio;
    \item Invalidãção de compras realizadas há mais de dois dias.
  \end{enumerate}

  \subsection{Modelagens}
    \subsubsection{SQLServer (Caio e Gabriel)}
    \subsubsection{MySQL}
    Para os testes com o SGBD MySQL, foi adotada a seguinte modelagem com quatro relações: Boleto; Cambio; Taxa; e Moeda.

    A relação Boleto representa uma operação de compra realizada, contendo os atributos id, data, pago (booleano), valor e id\_cambio.

    Por sua vez a relação Cambio representa as taxas do dia de uma dada moeda para outra com atributos id, id\_taxa\_origem, id\_taxa\_destino.

    Assim como deve ter sido possível inferir pelo nome, a relação Taxa, com atributos id, data, id\_moeda e valor, representa uma taxa de conversão para uma dada moeda em uma dada data.

    Por fim, a relação Moeda contém apenas o nome desta e sua id.

  \subsection{Resultados}
    \subsubsection{SQLServer (Caio e Gabriel)}
    \subsubsection{MySQL (Manzo \& Gordo)}


\begin{thebibliography}{1}

\bibitem{sweedish-article}
M. Minock, J. Mollevik and M. \r{A}sander, \textit{Toward an Active Database Platform for Guiding Urban Pedestrians}. Ume\r{a}, Sweden: University of Ume\r{a}, 2012.

\end{thebibliography}

\end{document}

